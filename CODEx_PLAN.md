# CODEx_PLAN.md — мастер‑план для `skillra_hse_pda`

Репозиторий: `skillra_hse_pda`  
Контекст:  
- Учебный проект по курсу **«Python для анализа данных»** (ВШЭ).  
- Продуктовый фундамент **Career & Job Market Navigator — Skillra**.

---

## 0. Контекст и ключевые файлы

### Данные и документация

- ТЗ курса: `docs/00_assignment_TZ.md`
- Продуктовый контекст Skillra: `docs/01_product_context_skillra.md`
- Словарь признаков hh-датасета: `docs/02_feature_dictionary_hh.md`
- Сырой датасет вакансий: `data/raw/hh_moscow_it_2025_11_30.csv`

### Код и ноутбуки

- Основной ноутбук проекта: `notebooks/01_hse_project.ipynb`
- Черновой командный ноутбук: `notebooks/Group_project_draft.ipynb` (источник идей, не основной отчёт)
- Python‑пакет проекта: `src/skillra_pda/`
  - `cleaning.py` — предобработка
  - `features.py` — новые признаки
  - `eda.py` — EDA‑утилиты
  - `viz.py` — визуализации
  - `personas.py` — продуктовый слой (персоны, skill‑gap)
  - `io.py`, `config.py` — I/O и пути
- Скрипты:
  - `scripts/validate_pipeline.py` — проверка пайплайна
  - `scripts/run_pipeline.py` — **должен быть создан** как единый пайплайн (см. CODEx_DIFF_PLAN)

---

## 1. Глобальные цели

### 1.1. Для учебного проекта (ВШЭ)

1. Реализовать все этапы 0–4 из ТЗ:
   - Этап 0 — парсинг hh (описан в ноутбуке, есть ссылку на парсер).
   - Этап 1 — предобработка: типы, пропуски, выбросы, очистка булевых.
   - Этап 2 — новые признаки: не меньше 2, фактически гораздо больше.
   - Этап 3 — разведочный анализ: таблицы, группировки, корреляции.
   - Этап 4 — визуализации: минимум 3 типа графиков, экспорт в `reports/figures/`.

2. Ноутбук `01_hse_project.ipynb`:
   - логичная структура по этапам,
   - есть раздел про парсер,
   - есть вклад участников,
   - есть текстовые выводы после ключевых блоков,
   - раздел с итоговыми выводами.

3. Код читабелен, воспроизводим и не завязан на магические пути.

### 1.2. Для продукта Skillra

1. **Карта рынка**:
   - зарплаты по ролям/грейдам/городам/доменам,
   - распределение форматов работы (office / hybrid / remote),
   - доля junior‑friendly вакансий.

2. **Аналитика навыков**:
   - частоты навыков по ролям/грейдам,
   - оценка salary‑premium за навыки,
   - разрезы по soft‑skills, бенефитам и работодателям.

3. **Персоны и skill‑gap**:
   - несколько типовых персон (студент, свитчер, middle),
   - для каждой — понимание рынка (сколько вакансий, какие вилки) и таблица skill‑gap.

4. **Продуктовый API**:
   - витрина рынка `market_view` в `data/processed/market_view.parquet`,
   - функции в `src/skillra_pda/personas.py` и `src/skillra_pda/market.py`, которые можно вызывать из Skillra‑сервиса или агента.

---

## 2. Что считается “готово”

### 2.1. Учебный проект

1. `notebooks/01_hse_project.ipynb`:
   - полностью выполняется **Run All**,
   - покрывает Этапы 0–4,
   - содержит текстовые выводы после основных EDA и визуализаций,
   - содержит раздел про персоны и skill‑gap,
   - содержит финальный раздел с итоговыми выводами.

2. В `reports/figures/` есть набор осмысленных графиков:
   - зарплаты по ролям/грейдам/городам,
   - распределение форматов работы,
   - распределение/heatmap навыков, soft‑skills и/или бенефитов,
   - корреляционная матрица.

3. `docs/02_feature_dictionary_hh.md` описывает:
   - исходные признаки парсера,
   - все ключевые engineered features (город/формат, стек, джуниор‑френдли, bucket’ы зарплат и т.п.).

### 2.2. Продуктовый слой Skillra

1. Есть модуль `market.py` с функцией `build_market_view(df_features)` и сохранённой витриной `data/processed/market_view.parquet`.
2. В `personas.py` есть high‑level функция `analyze_persona(df, persona)`:
   - возвращает краткий `market_summary`,
   - возвращает таблицу skill‑gap,
   - возвращает список рекомендованных навыков.
3. В ноутбуке есть примеры использования `analyze_persona` для нескольких персон.
4. README (и/или docs) объясняют:
   - как запускать пайплайн,
   - как использовать market_view и personas в Skillra.

---

## 3. Архитектура модулей (target‑состояние)

- `cleaning.py` — только предобработка:
  - parse/normalize дат,
  - нормализация булевых/строковых полей,
  - обработка пропусков,
  - подготовка зарплат (`salary_mid_rub_capped`, `salary_known`),
  - дедупликация.

- `features.py` — feature engineering:
  - временные признаки (день недели, месяц, возраст вакансии),
  - `city_tier`, `work_mode`,
  - агрегаты по навыкам/стеку/soft‑skills/бенефитам,
  - `primary_role`, `salary_bucket`,
  - текстовые длины и счётчики.

- `eda.py` — агрегаты и статистика:
  - общие helpers: missing_share, describe_salary_by_group/two_dim, correlation_matrix,
  - EDA по английскому и образованию,
  - EDA по доменам,
  - EDA по работодателям, бенефитам и soft‑skills.

- `viz.py` — графики:
  - зарплаты по ролям/грейдам/городам/доменам,
  - распределение work_mode,
  - barplot’ы по навыкам и премиям,
  - heatmap’ы (корреляции, бенефиты/soft‑skills по компаниям),
  - сохранение картинок в `reports/figures`.

- `personas.py` — продуктовая логика:
  - dataclass Persona,
  - функции фильтрации рынка по персоне,
  - построение demand‑profile,
  - `skill_gap_for_persona`,
  - `analyze_persona`.

- `market.py` — агрегированная витрина:
  - `build_market_view(df_features)`.

- `io.py` и `config.py` — пути и I/O.

- `scripts/validate_pipeline.py` — быстрый smoke‑тест.
- `scripts/run_pipeline.py` — полный проход: raw → clean → features → market_view.

---

## 4. Жёсткие правила для Codex

1. Не трогать `data/raw/*`.
2. Не ломать Run All для `notebooks/01_hse_project.ipynb`.
3. Не удалять существующие визуализации и EDA‑функции без крайней необходимости.
4. Новые признаки → обновить `docs/02_feature_dictionary_hh.md`.
5. Новые функции/модули → добавить docstring и (по возможности) простой тест.
6. Любые крупные изменения в структуре — только если это прямо описано в `CODEx_DIFF_PLAN.md` или в явных инструкциях пользователя.

---

## 5. Как использовать этот план

- `AGENTS.md` задаёт общие правила.
- `CODEx_PLAN.md` — отвечает на вопрос «что вообще считаем целевым состоянием».
- `CODEx_DIFF_PLAN.md` — **конкретный** список задач и изменений, которые нужно сделать в текущей кодовой базе.

Codex и другие ИИ‑агенты должны:
1. Сначала прочитать `AGENTS.md` и `CODEx_PLAN.md`.
2. Затем выполнять шаги из `CODEx_DIFF_PLAN.md`, не отступая от этих правил.
